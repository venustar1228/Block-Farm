var property_json = {
"solidity": "pragma solidity ^0.4.2;\n\ncontract Property{\n\n    struct PropertyType{\n        string name;\n        uint id;\n        uint[] rating;\n        uint averageRating;\n    }\n\n    PropertyType[] public propertyTypeList;\n\n    modifier onlyOwner()\n    {\n        if(msg.sender != owner) throw;\n        _;\n    }\n\n    address owner;\n\n    function Property(){\n        owner = msg.sender;\n    }\n\n    function updatePropertyTypeRating(uint _id, uint rate, string operation, uint s_Length, uint s_Id) onlyOwner{\n        if (equal(operation,'update')){\n\n            uint old_rating = propertyTypeList[_id].rating[s_Id];\n            var total = propertyTypeList[_id].averageRating;\n            total = total - old_rating;\n            total = total + rate;\n            propertyTypeList[_id].averageRating = total;\n            propertyTypeList[_id].rating[s_Id] = rate;\n\n        }else if (equal(operation,'new')){\n\n            for (uint j = 0 ; j < _id ; j++){\n                propertyTypeList[j].rating.push(0);\n            }\n        }\n    }\n\n    function addPropertyType(string _name, uint s_Length) onlyOwner{\n        uint _id = propertyTypeList.length++;\n        for (uint j = 0 ; j < s_Length ; j++){\n            propertyTypeList[_id].rating.push(0);\n        }\n\n        PropertyType prop = propertyTypeList[_id];\n        prop.name = _name;\n        prop.id= _id;\n        prop.averageRating = 0;\n\n    }\n\n    function getPropertyType(uint p_Id) constant returns(string, uint, uint, uint[]){\n        return(propertyTypeList[p_Id].name, propertyTypeList[p_Id].id, propertyTypeList[p_Id].averageRating, propertyTypeList[p_Id].rating);\n    }\n\n    function getPropertyTypeByUserId(uint p_Id, uint s_Id) constant returns(string, uint, uint, uint){\n        return(propertyTypeList[p_Id].name, propertyTypeList[p_Id].id, propertyTypeList[p_Id].averageRating, propertyTypeList[p_Id].rating[s_Id]);\n    }\n\n    function getPropertyTypeId(uint p_Id) constant returns(uint){\n        return propertyTypeList[p_Id].id;\n    }\n\n    function getPropertyTypeLength() constant returns(uint){\n        return propertyTypeList.length; \n    }\n\n    /// @dev Does a byte-by-byte lexicographical comparison of two strings.\n    /// @return a negative number if `_a` is smaller, zero if they are equal\n    /// and a positive numbe if `_b` is smaller.\n    function compare(string _a, string _b) returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        //@todo unroll the loop into increments of 32 and do full 32 byte comparisons\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n    }\n    /// @dev Compares two strings and returns true iff they are equal.\n    function equal(string _a, string _b) returns (bool) {\n        return compare(_a, _b) == 0;\n    }\n    /// @dev Finds the index of the first occurrence of _needle in _haystack\n    function indexOf(string _haystack, string _needle) returns (int)\n    {\n      bytes memory h = bytes(_haystack);\n      bytes memory n = bytes(_needle);\n      if(h.length < 1 || n.length < 1 || (n.length > h.length))\n        return -1;\n      else if(h.length > (2**128 -1)) // since we have to be able to return -1 (if the char isn't found or input error), this function must return an 'int' type with a max length of (2^128 - 1)\n        return -1;\n      else\n      {\n        uint subindex = 0;\n        for (uint i = 0; i < h.length; i ++)\n        {\n          if (h[i] == n[0]) // found the first char of b\n          {\n            subindex = 1;\n            while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]) // search until the chars don't match or until we reach the end of a or b\n            {\n              subindex++;\n            }\n            if(subindex == n.length)\n              return int(i);\n          }\n        }\n        return -1;\n      }\n    }\n\n}\n",
"params":[],
"publish": ["Property"],
"private": privateKey,
"gas_limit": 3000000
}
